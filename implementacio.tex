\chapter{Implementació}
\label{chap:implementacio}

La implementació del joc s'ha realitzar amb dos grans blocs: el servidor i la interfície client. El servidor es l'encarregat de gestionar la informació relativa a les partides disponibles, els jugadors connectats i tota la lògica referent a les partides. La interfície client s'encarrega de interaccionar amb el servidor i mostrar la informació al usuari. 

Per l'intercanvi de dades entre el servidor i el client s'utilitzen WebSockets\footnote{Veure Capítol \ref{sec:websockets}}, ja que ens proporcionen un canal de comunicació bi-direccional a través del protocol HTTP. Aquesta comunicació es totalment asíncrona i està basada en esdeveniments. Així cada vegada que el servidor envia un missatge al client (o a l'invers) es produeix un esdeveniments al destinatari i s'executa el codi associat per al processament d'aquest esdeveniments (en cas que n'hi hagi). 

\section{Servidor}

El servidor s'encarrega de les següents tasques: 

\begin{itemize}
\item{Proporcionar un servidor web encarregat de servir el programa client per a cada connexió.}
\item{Emmagatzemar les partides en curs i jugadors connectats. Proporcionar esdeveniments a través de WebSockets per a que els usuaris puguin interaccionar a través del programa client. }
\item{Aplicar les regles de la botifarra a cada joc en curs i interactuar amb els diferents clients connectats a una partida}
\end{itemize}

En les properes seccions s'explica més profundament com s'ha realitzat la implementació de cadascuna de les tasques. 

\subsection{Servidor Web}

El servidor web és el proces més important de tot el projecte, ja que és l'encarregat de servir les altres parts de tot el projecte. 

Per la implementació del servidor web s'ha utilitzat el paquet express\footnote{\url{http://expressjs.com/}}. Aquest paquet ens permet desenvolupar servidors web a amb poques línies de codi. Així també disposa de codi pre-programat per tal de realitzar tasques comunes a tots el servidors web. Alguns exemples en són:

\begin{itemize}
\item{Registre de peticions.}
\item{Servir fitxers estàtics (imatges,css,JavaScript,etc.).}
\item{Gestió d'errors}
\item{Gestió de galetes (Cookies).}
\end{itemize}

A part de totes aquests funcionalitats, express també s'integra amb diferents llenguatges de plantilles per simplificar l'escriptura del codi HTML. Alguns exemples de motors de plantilles suportats per express són: 

\begin{description}
\item[Haml] {Implementació de Haml\footnote{\url{http://haml-lang.com/}} }
\item[Jade] {Successor de Haml}
\item[EJS] {JavaScript Incrustat}
\item[CoffeeKup] {Plantilles basades amb CoffeeScript}
\item[jQuery Templates for node]
\end{description}

Per la implementació del projecte s'ha utilitzat el motor de plantilles Jade, ja que ens permeten una gran simplificació del codi HTML.

La conjunció de tots els elements comentats anteriorment ens permeten disposar d'un servidor web sobre node.js. Això vol dir que les peticions es processen de forma asíncrona. 

\subsection{Interconnexió Jugadors}
\label{sec:interconnexio-jugadors}
A part de funcionar com a servidor web el servidor també ha d'intercanviar dades amb els clients connectats amb ells. Per això el servidor crear un WebSocket i proporcionar els mecanismes suficients per a que el client s'hi connecti. Així, quan es carrega la primera pàgina de la partida també es carrega el programa client i aquest es connecta al servidor. 

A través de la comunicació amb WebSockets el servidor es poden realitzar les següent accions: 

\begin{description}
\item[login] {Identificar-se amb el servidor.}
\item[create-game] {Crear una nova partida}
\item[join-game] {Entrar a una partida existent.}
\item[watch-game] {Mirar una partida existent.}
\item[add-bot] {Afegir un robot a una partida existent.}
\item[list-games] {Obtenir una llista de totes les partides disponibles al servidor.}
\item[list-players] {Obtenir una llista de tots els jugadors que hi ha al servidor.}
\item[send] {Enviar un missatge a tota la resta d'usuaris del servidor. }
\end{description}

Cada programa client que es vulgui implementar ha d'utilitzar la comunicació amb WebSockets a través d'aquests esdeveniments per interactuar amb l'usuari que vol jugar al servidor. Així la comunicació amb WebSockets permet que es pugin implementar més d'un programa client sense tenir que fer cap tipus de modificació al programa servidor. 

\subsection{Lògica Botifarra}

El servidor també és l'encarregat de controlar tot el flux de treball de la botifarra. A la figura \ref{fig:buti-workflow} es pot veure una representació del flux de treball d'una partida de la botifarra, des de que es crea la partida, fins que aquesta es finalitzada. En aquesta figura s'indica amb color blau les funcions que realitzar el programa servidor i amb color verd les que ha de realitzar el propi jugador que està connectat a la partida. 

\begin{figure}[htbp]
\hspace*{-1.5in}
\centering\includegraphics{img/butifarra_workflow.png}
\caption{Flux de treball de la botifarra}
\label{fig:buti-workflow}
\end{figure} 

\newpage

Com es pot observar a la figura \ref{fig:buti-workflow} el servidor s'encarrega de realitzar les següents tasques referents a la botifarra: 

\begin{itemize}
\item{Començar la partida quan ja hi ha quatre jugadors. }
\item{Repartir de forma aleatòria els jugadors amb dos equips. }
\item{Tirar de forma aleatòria el primer jugador en elegir triomf.}
\item{Repartir les cartes de forma aleatòria entre els diferents jugadors}
\item{Comunicar el triomf elegit a tots els jugadors.}
\item{Comunicar als jugadors si hi ha algun jugador que contrar.}
\item{Determinar el jugador a moure i notificar-lo de que es el seu torn.}
\item{Validar que la carta jugada es la correcta}
\item{Mostrar les cartes de cada jugada.}
\item{Al final de cada ronda mostrar el resultat parcial de la ronda. }
\item{Al final de cada ronda calcular la puntuació de cada equip. En el cas que hi hagi un equip guanyador finalitzar la partida. En el cas que no hi hagi cap jugador guanyador inicial una nova ronda.}
\end{itemize}

Tota la lògica de la botifarra s'ha realitzat a base d'esdeveniments, es a dir, cada vegada que es produeix un acció que requereix la intervenció del servidor aquest llança un esdeveniment que té associada una funció. Aquesta funció es l'encarregada de realitzar tot el processament i llençar el pròxim esdeveniment en cas de que sigui necessari.  


\subsubsection{Aleatorietat}

Un punt molt important per a que els jugadors disfrutin de la seva partida de la botifarra és l'aleatorietat del repartiment de les cartes. Per garantir aquesta aleatorietat s'ha implementar l'algorisme de Knuth Fisher Yates\footnote{\url{http://en.wikipedia.org/wiki/Fisher-Yates_shuffle}} que permet la generació d'una permutació aleatòria sobre un conjunt finit. En el nostre cas el nostre conjunt finit es correspon amb les 48 cartes de la baralla espanyola utilitzades per jugar a la botifarra. 

Donat un conjunt de nombre de 1 a N, aquest algoritme s'aplica de la següent forma: 
\begin{enumerate}
\item{Escriure els nombre de 1 a N.}
\item{Agafar un nombre aleatori k entre 1 i el nombre d'elements pendents de tractar (inclusiu)}
\item{Contant per la part més baixa, treure el número de la posició k que encara no s'ha tractat i escriure'l a un altre lloc}
\item{Repetir el segon pas fins que s'hagin tractat tots els nombres}
\item{El conjunt de nombres que s'han escrit al pas 3 es una permutació aleatòria del conjunt de nombres inicials}
\end{enumerate}

Aquest algorisme te un cost $O(n^2)$ per això s'ha utilitzat la variant de Knuth que permet optimitzar l'algorisme fins a obtenir un cost de $O(n)$. Aquesta variant el que fa es moure els elements pendents de tractar al final de lla llista. Així l'algorisme es queda expressat de la següent forma: 

\begin{lstlisting}
 Per ordenar un conjunt de n elements (indexs 0..n-1):
   Per cada i de n - 1 fins a 1 fer:
        j <- nombre aleatori que compleix que  0 <= j <= i
        canviar a[j] i a[i]
\end{lstlisting}

A més a més per tal de garantir la complerta aleatorietat i evitar possibles resultats iguals aquest algorisme s'aplica 12 vegades. Amb això s'aconsegueix emular el comportament humà al barrejar la baralla de cartes. 

\section{Client}

El client s'encarrega de realitzar les següents tasques: 

\begin{itemize}
\item{Interaccionar amb el servidor a través de WebSockets.}
\item{Mostrar al usuari les dades que rep del servidor.}
\end{itemize}

Aquestes funcionalitats s'han implementat de forma separada per poder garantir que els canvis a la interfície d'usuari no afectin al la interacció amb el servidor. Aquesta separació ens permet canviar la forma en que es mostren les dades sense tenir que realitzar cap modificació a la lògica del client. Això també ens permet disposar de dos interfícies d'usuari (una per equips d'escriptori i l'altra per a mòbils, per exemple) que utilitzen els mateixos mecanismes per tal d'interactuar amb el servidor. 

En els següents apartats s'explicam com s'han implementat aquestes dos funcionalitats. 

\subsection{Lògica del client}

Per tal d'implementar la comunicació entre el client i el servidor s'ha utilitzat la llibreria socket.io. Aquesta llibreria proporciona els mètodes necessaris per la comunicació entre client servidor. També porta un fitxer JavaScript que es pot servir a través d'un servidor web. Aquest és el mètode emprat en la nostra implementació. A través d'aquest fitxer JavaScript obtenim els mètodes suficients per connectar-nos al servidor i poder enviar/rebre missatges. En el nostre cas el client proporciona els mètodes per poder interaccionar amb el servidor i obtenir tota la informació comentada en la secció \ref{sec:interconnexio-jugadors}. A més a més s'encarrega d'escoltar els següents següents missatges: 

\begin{description}
\item[welcome]{Missatge de benvinguda del servidor.}
\item[message]{Rep els missatges enviats per altres jugadors.}
\item[updated-game]{Informa sobre l'actualització d'informació d'una partida. }
\item[start]{Una partida que l'usuari es jugador comença.}
\item[select-thriumph]{Informa al jugador que ha de seleccionar el trumfo de la partida. }
\item[notify-thriumph]{Informa al jugador el trumfo seleccionat pels altres jugadors.}
\item[play-card]{El jugador ha de seleccionar una carta per jugar. }
\item[played-card]{S'ha jugat una carta.}
\item[new-move]{Comença una nova basada.}
\item[end-move]{S'ha finalitzat la basada activa.}
\item[contro]{El jugador té la possibilitat de contrar.}
\item[contro-done]{Informa que un altre jugador ha contrat.}
\item[round-ended]{S'ha finalitzat la ronda.}
\item[game-ended]{S'ha finalitzat la partida.}
\end{description}

Cada vegada que es rep un missatge d'aquest tipus el programa client s'encarrega de processar la informació i de cridar al programa de visualització de la informació \footnote{Veure secció \ref{sec:visualitzacio-informacio}} per a que mostri la informació a l'usuari. El programa client també s'encarrega de refrescar la informació del servidor de forma periòdica. 



\subsection{Visualització de la informació}
\label{sec:visualitzacio-informacio}

Com ja s'ha comentat anteriorment, el programa encarregat de mostrar la informació a l'usuari s'ha implementat de forma separada per tal de poder permetre múltiples tipus de client. El client per defecte s'ha escrit utilitzant una interfície web. Així, el programa de visualització de la informació es l'encarregat de mostrar en una pàgina web l'in formació que es rebi a través del programa client.

Per tal de poder dibuixar l'àrea de joc de la partida i les cartes que juguen cada jugador s'ha utilitzat l'objecte canvas introduït en la última versió del llenguatge HTML. Aquest objecte proporciona un espai on poder realitzar dibuixos de forma dinàmica a través de JavaScript. Gràcies a que s'escriu a través de JavaScript ens permet dibuixar-hi sense tenir que tornar a carregar la pàgina. Aquest fet provoca que l'usuari pugui veure moviment a la pantalla. 

En la implementació per defecte, l'objecte canvas forma tot un conjunt independentment del nombre d'objectes que tenim dibuixat al seu interior. Així només és pot associar esdeveniments a l'objecte en canvas i no als elements que estan continguts al seu interior. Un dels requisits del joc es que es puguin associar esdeveniments a objectes de dins del canvas, per exemple associar un esdeveniments que cada vegada que es faci clic sobre una carta s'enviï una petició al servidor sol·licitant que es vol jugar. Per tal de solucionar aquest problema s'ha utilitzat la llibreria kinetic.js\footnote{\url{http://www.kineticjs.com/}}. A més d'associar esdeveniments als objectes de dins aquesta llibreria ens permet estructurar el dibuix a nivell de capes, permetent-nos crear tantes capes com es cregui necessari. La llibreria s'encarrega de superposar totes les capes i mostrar-les a l'usuari. 

\section{Exemples de comunicació}

En aquest apartat es mostraran alguns exemples de la comunicació que es dur a terme entre el client i el servidor, detallant els missatges que s'intercanvien. 

\begin{figure}[h!]
\centering
\begin{sequencediagram}
\newthread[white]{c}{Client}
\newinst[9]{s}{Servidor}
 
\begin{call}{c}{Establir conexió}{s}{welcome}
\end{call}

\begin{call}{c}{login}{s}{Informació del usuari}
\end{call}

\begin{call}{c}{new-game}{s}{Informació de la partida creada}
\end{call}

\end{sequencediagram}
\caption{Diagrama de flux de creació d'una nova partida.}
\label{diag:creacio-nova-partida}
\end{figure} 

A la figura \ref{diag:creacio-nova-partida} es pot observar el diagrama de flux necesàri per a la creació d'una nova partida. En el primer pas el programa client estableix la connexió amb el programa servidor que li contesta donant-li la benvinguda al servidor i preguntant-li el seu nom d'usuari. Una vegada el programa client envia el nom d'usuari el programa servidor li contesta amb l'identificador usuari que te asignat. Una vegada s'ha identificat el programa 


\begin{figure}[h!]
\centering
\begin{sequencediagram}
\newthread[white]{c}{Client}
\newinst[9]{s}{Servidor}
 
\begin{call}{c}{Establir conexió}{s}{welcome}
\end{call}

\begin{call}{c}{login}{s}{Informació del usuari}
\end{call}

\begin{call}{c}{list-games}{s}{Llista de partides}
\end{call}

\begin{call}{c}{join-game(id)}{s}{Confirmació.}
\end{call}

\end{sequencediagram}
\caption{Diagrama de flux per entrar a una partida existent.}
\label{diag:entrar-partida}
\end{figure} 

A la figura \ref{diag:entrar-partida} es pot observar el diagrama de flux necesàri per a la creació d'una nova partida. En el primer pas el programa client estableix la connexió amb el programa servidor que li contesta donant-li la benvinguda al servidor i preguntant-li el seu nom d'usuari. Una vegada el programa client envia el nom d'usuari el programa servidor li contesta amb l'identificador usuari que te asignat. Una vegada s'ha identificat el programa 

\begin{figure}[h!]
\centering
\begin{sequencediagram}
\newthread[white]{s}{Servidor}
\newinst[9]{c}{Client}
 
\begin{messcall}{s}{start-game(game-data)}{c}
\end{messcall}

\begin{sdblock}{ Ronda } { Mentre no hi haigi equip guanyador.}

   \begin{call}{s}{select-thriumph(choises)}{c}{made-thriumph(thriumph)}
    \end{call}

    \begin{messcall}{s}{chosen-thriumph(thriumph)}{c}
    \end{messcall}

    \begin{call}{s}{contro}{c}{do-contro(value)}
    \end{call}

    \begin{messcall}{s}{new-move)}{c}
    \end{messcall}

    \begin{sdblock}{ Jugada } { Fins que no quedin cartes per jugar }
        
        \begin{messcall}{s}{play-card}{c}
        \end{messcall}
        
        \begin{messcall}{c}{play-card}{s}{missatge-error}
        \end{messcall}
        
        \begin{messcall}{s}{played-card}{c}
        \end{messcall}    
        
    \end{sdblock}

    \begin{messcall}{s}{end-move)}{c}
    \end{messcall}

\end{sdblock}
 
\begin{messcall}{s}{end-game(game-data)}{c}
\end{messcall}

\end{sequencediagram}
\caption{Diagrama de flux del desenvolupament d'una partida.}
\label{diag:desenvolupament-partida}
\end{figure} 


A la figura \ref{diag:desenvolupament-partida} es pot observar el diagrama de flux del desenvolupmaent d'una partida. En aquest cas s'han omès els pasos de creació d'una nova partida i que cada jugador entri dins de la partida. La partida comença quan el servidor notifica a tots els jugadors de la partida que aquesta ha comensat. Durant el transcurs de la partida es van jugant diferents rondes. En cada ronda el servidor notifica al client que ha de seleccionar thriumph les opcions que té diferent i espera la resposta del client. Una vegada el client ha seleccionat triomf, notifica a tots els jugadors de la partida quin ha estat el triomf seleccionat. Després d'això, notifica als jugadors que tenen la posibilitat de contrar i espera la seva resposta. Una vegada s'ha realitzat el proces de contro, el servidor indica el començament d'una nova jugada amb el missatge new-move. Cada jugada consisteix en un movimient (nova carta jugada) de cadascun dels jugadors de la partida. Així per cada moviment del jugador el servidor notifica al client que ha de realitzar un nou movimient i espera rebre el missatge de que s'ha jugat una nova carta. Quan el client envia el missatge de que vol jugar una nova carta el servidor valida que el moviment sigui correcte. En el cas de que aquest sigui incorrecte ho notifica al client i espera la jugada d'una nova carta. En el cas contrari, notifica a la resta de jugadors la carta que s'ha jugat i repeteix de nou la jugada. Així es van produïnt jugades fins que s'han acabat totes les cartes de tots els jugadors, concretament es tracta de 12 jugades. Una vegada s'han jugat totes les cartes la ronda es dona per finalitzada i el servidor computa les puntuacions de la partida. En el cas que no s'haigi finalitzat la partida es comença la ronda i es torna a repetir tot el procediment realitzat anteriorment. Si hi ha un equip guanyador la partida es dona per finalitzada i es notifica a tots els clients. 


